package schema

import (
	"errors"
	"fmt"
	"reflect"
	"strings"
)

var ErrUnsupportedType = errors.New("unsupported type in store generation")
var ErrInvalidMapKey = errors.New("invalid map key")
var ErrValueNotFound = errors.New("value not found in store")

func (store EntityStore) Get(value EntityValue) (EvalValue, error) {
	for _, item := range store {
		ok, err := item.Uid.OpEqual(value)
		if err != nil {
			return nil, err
		}
		if ok {
			return item.Attrs, nil
		}
	}
	return nil, ErrValueNotFound
}

func NewVariablesFromMap(data map[string]any) (VarValue, error) {
	val, err := walkStore(reflect.ValueOf(data))
	if err != nil {
		return VarValue{}, err
	}

	if v2, ok := val.(VarValue); ok {
		return v2, nil
	}
	return VarValue{}, ErrUnsupportedType
}

func NewVariablesFromMapMust(data map[string]any) VarValue {
	val, err := NewVariablesFromMap(data)
	if err != nil {
		panic(err)
	}
	return val
}

func EntityStoreDataFromMap(data map[string]any) (NamedType, error) {
	return walkStore(reflect.ValueOf(data))
}

func walkSlice(v reflect.Value) (NamedType, error) {
	// Prefer empty list over nil
	result := SetValue{}
	for i := 0; i < v.Len(); i++ {
		v, err := walkStore(v.Index(i))
		if err != nil {
			return nil, err
		}
		result = append(result, v)
	}
	return result, nil
}

func specialEntity(value NamedType) (NamedType, error) {
	// special handling of entity
	val, ok := value.(VarValue)
	if !ok {
		return nil, fmt.Errorf("invalid format for __entity: %w", ErrInvalidEntityFormat)
	}

	id, found := val.children["id"]
	if !found {
		return nil, fmt.Errorf("missing 'id' property : %w", ErrInvalidEntityFormat)
	}
	if id.TypeName() != "string" {
		return nil, fmt.Errorf("expected string type for id got %s: %w", id.TypeName(), ErrInvalidEntityFormat)
	}
	kind, found := val.children["type"]
	if !found {
		return nil, fmt.Errorf("missing 'type' property: %w", ErrInvalidEntityFormat)
	}
	if id.TypeName() != "string" {
		return nil, fmt.Errorf("expected string type for type got %s: %w", id.TypeName(), ErrInvalidEntityFormat)
	}

	parts := strings.Split(kind.String(), "::")
	return EntityValue(append(parts, id.String())), nil
}

func walkMap(v reflect.Value) (NamedType, error) {
	result := VarValue{
		children: map[string]NamedType{},
	}
	iter := v.MapRange()
	for iter.Next() {
		k := iter.Key()
		if k.Kind() != reflect.String {
			return nil, fmt.Errorf("invalid map key %v: %w", k.Kind(), ErrInvalidMapKey)
		}
		val, err := walkStore(iter.Value())
		if err != nil {
			return nil, err
		}
		if k.String() == "__entity" {
			val, err = specialEntity(val)
			if err != nil {
				return nil, err
			}

			return val, nil
		}

		result.children[k.String()] = val
	}
	return result, nil
}

func walkStruct(v reflect.Value) (NamedType, error) {
	return nil, ErrUnsupportedType
}

func walkStore(v reflect.Value) (NamedType, error) {
	// fmt.Printf("Visiting %v\n", v)
	// Indirect through pointers and interfaces
	for v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface {
		v = v.Elem()
	}
	switch v.Kind() {
	case reflect.Array, reflect.Slice:
		v, err := walkSlice(v)
		if err != nil {
			return nil, err
		}
		return v, nil
	case reflect.Map:
		v, err := walkMap(v)
		if err != nil {
			return nil, err
		}
		return v, nil
	case reflect.Struct:
		return walkStruct(v)
	// 	err := walkStruct(v)
	// 	if err != nil {
	// 		return nil, err
	// 	}

	case reflect.Bool:
		return BoolValue(v.Bool()), nil
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return IntValue(v.Int()), nil
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return IntValue(int(v.Uint())), nil
	case reflect.Float32, reflect.Float64:
		return StrValue(fmt.Sprintf("%f", v.Float())), nil
	case reflect.String:
		return StrValue(v.String()), nil

		// Not supported
		// case reflect.Uintptr:
		// case reflect.Complex64:
		// case reflect.Complex128:
		// case reflect.Chan:
		// case reflect.Func:
		// case reflect.Interface:
		// case reflect.Pointer:
		// case reflect.UnsafePointer:
	}
	return nil, ErrUnsupportedType
}
